package dps.hoffmann.proxy.service;

import dps.hoffmann.proxy.exception.InvalidJsonException;
import dps.hoffmann.proxy.model.LogicalService;
import dps.hoffmann.proxy.model.RequestMapper;
import dps.hoffmann.proxy.model.ScalingDirection;
import dps.hoffmann.proxy.model.ScalingInstruction;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.RandomStringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static dps.hoffmann.proxy.model.ScalingDirection.DOWN;
import static dps.hoffmann.proxy.model.ScalingDirection.UP;

/**
 * Service that translates the a given json body generated by prometheus
 * or its alertmanager to a given request type enum member
 */
@Service
@Slf4j
public class TranslationService {

    private static final int BATCH_INSTRUCTION_ID_LEN = 10;

    @Value("${translation.fieldname}")
    private String fieldName;

    @Autowired
    private RequestMapper requestMapper;

    /**
     * translates the a given json body generated by prometheus or its
     * alertmanager to a given request type enum member
     *
     * @param jsonBody request body comming from the prometheus / alertmanager
     * @return enum member representing request type
     */
    public List<ScalingInstruction> translateAlertManJson(String jsonBody) {
        RequestMapper.InstructionType requestMapper = parseRequestType(jsonBody);
        log.info("found type for json value: {}", requestMapper);
        return createInstructions(requestMapper);
    }

    private RequestMapper.InstructionType parseRequestType(String jsonBody) {
        // todo maybe use ObjectMapper to translate to map ???
        log.info("json body");
        String patternStr = ".*" + fieldName + "\":\"(.*?)\",.*";
        Pattern patternObj = Pattern.compile(patternStr);
        Matcher matcher = patternObj.matcher(jsonBody);

        if (!matcher.find() || matcher.groupCount() != 1) {
            String msg = "could not find key with name \"" + fieldName + "\" in json body";
            log.error(msg);
            throw new InvalidJsonException(msg);
        }

        String jsonValue = matcher.group(1);
        log.info("parsed translation instruction: {}", jsonValue);


        // todo maybe use streams
        RequestMapper.InstructionType requestMapper = null;
        for (RequestMapper.InstructionType type : RequestMapper.InstructionType.values()) {
            if (jsonValue.equalsIgnoreCase(type.getRequestName())) {
                requestMapper = type;
            }
        }

        if (requestMapper == null) {
            String error = "could not find type for json value: " + jsonValue;
            log.error(error);
            throw new InvalidJsonException(error);
        }

        return requestMapper;
    }

    private List<ScalingInstruction> createInstructions(RequestMapper.InstructionType instructionType) {
        List<ScalingInstruction> out = new ArrayList<>();

        int scalingInterval = requestMapper.getScalingInterval(instructionType);
        log.info("scaling interval: {}", scalingInterval);
        LogicalService logicalServiceName = instructionType.getLogicalService();
        String swarmServiceName = requestMapper.getServiceName(instructionType);
        ScalingDirection scalingDirection = instructionType.getScalingDir();
        String scalingBatchId = RandomStringUtils.randomAlphabetic(BATCH_INSTRUCTION_ID_LEN);

        for (int i = 0; i < scalingInterval; i++) {

            ScalingInstruction instr = ScalingInstruction.builder()
                    .scalingBatchId(scalingBatchId)
                    .scalingDirection(scalingDirection)
                    .logicalServiceName(logicalServiceName)
                    .swarmServiceName(swarmServiceName)
                    .build();

            out.add(instr);
        }

        return out;
    }


    public List<ScalingInstruction> translateManualScaleInstr(LogicalService service,
                                                              int additionalService) {
        List<ScalingInstruction> out = new ArrayList<>();

        String swarmServiceName = requestMapper.getServiceName(service);
        ScalingDirection scalingDirection = additionalService >= 0 ? UP : DOWN;
        String scalingBatchId = RandomStringUtils.randomAlphabetic(BATCH_INSTRUCTION_ID_LEN);

        for (int i = 0; i < Math.abs(additionalService); i++) {

            ScalingInstruction instr = ScalingInstruction.builder()
                    .scalingBatchId(scalingBatchId)
                    .scalingDirection(scalingDirection)
                    .logicalServiceName(service)
                    .swarmServiceName(swarmServiceName)
                    .build();

            out.add(instr);
        }

        return out;
    }
}
